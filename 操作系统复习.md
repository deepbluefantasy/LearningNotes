[TOC]

# 操作系统复习

> 教科书：《操作系统》（第3版），孟庆昌、牛欣源、张志华、路旭强编著
>
> 注：2.5后的内容不全



## 第一章	引论

### 1.1 计算机硬件结构

- **冯诺依曼体系结构**（采用存储程序工作原理）

  - 把计算过程描述为由许多条命令按一定顺序组成的程序，然后把程序和所需的数据一起输入计算机存储器中保存起来，工作时控制器执行程序，控制计算机自动连续进行运算。

- 计算机五大部件：

  - 运算器、控制器、存储器、输入设备、输出设备。
  - 运算器+控制器=CPU（集成在大规模集成电路中，称中央处理器）

- 中央处理器

  - **CPU工作周期**：提取指令、译码分析、执行指令
  - **处理机执行状态**

    - 核心态（系统态、管理态）：执行操作系统程序，权限较高、能执行所有的指令
    - 用户态：执行用户用户程序，权限较低、只能执行指令集中的非特权指令

    > 目的：为了保护操作系统程序(特别是内核部分)，防止收到用户程序的损害

- 存储器

  - 分类

    - 寄存器：最快最贵，需通电保存信息

    - 高速缓存（Cache）：极快极贵，需通电

    - **内存（主存）**：RAM，随机存取存储器，需通电

      > **内存的编制单位一般是字节。也有以字为单位的，但这样会导致编码较少，所以不常用。**

    - 磁盘（辅存、外存）：即硬盘，不需通电

    - 磁带：超级慢，不需通电

      ![img](https://raw.githubusercontent.com/deepbluefantasy/markdown-image/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/a28904034d6064f947f8d47f22e313d2.jpg)

### 1.2 什么是操作系统

1. **是扩展机器**：为只能使用01码的裸机提供各种实用命令，如直接打开文件、读写文件等等

> 裸机就是只有硬件的计算机。

1. **是资源管理器**：管理各硬件和软件资源（时分复用、空间复用）
   - 监视各种资源，随时记录他们的状态
   - 实施某种策略以决定谁获得资源、何时获得、获得多少
   - 分配资源供需求者使用
   - 回收资源、以便再分配
2. 定义：**操作系统是控制和管理计算机系统内各种硬件和软件资源，有效地组织多道程序运行的系统软件，是用户与计算机之间的接口**
3. 地位：**操作系统是整个计算机系统的控制管理中心，其他所有软件都是建立在操作系统之上。操作系统对他们就有支配权力，又为其运行建造必备环境。**

- 软件分类

  - 应用软件：为特定需要而设计的程序，如qq（机器中不可或缺）

  - 支撑软件：各种开发工具

  - 系统软件：操作系统、编译程序等

5. **操作系统的特征**

  - 并发性：两个或多个活动在同一给定的时间间隔中进行。

    > 宏观上同时，实际上并不同时，分时间片单独运行，时间片极短。
    >
    > 同一时刻进行叫“并行”，需要多个CPU。

  - 共享性：计算机系统中的资源被多个进程共用，如共享内存、共享CPU

  - 不确定性：系统中各种事件的发生顺序不可预测，由并发性和资源共享导致的必然结果。

### 1.2.2 操作系统的功能

> 这一节内容很多，拿出来单独放置

1. **存储管理**

  - 内存分配：记录内存的使用情况，处理用户提出的申请，按照某种策略实施分配，接收系统或用户释放的内存空间

  - 地址映射：将逻辑地址转换为内存的物理地址

  - 内存保护：防止两个程序申请的内存重合、防止程序越界

  - 内存扩充：使用虚拟存储技术，用磁盘空间替代内存

2. **作业和进程管理**

> 作业：用户的计算任务
> 进程：程序的执行过程
> 线程：进程的下一级单位

  * 作业和进程调度

    * 挑选合适作业调度入内存，为其建立进程
    * 挑选合适进程在CPU中运行
  * 进程控制：创建进程、撤销进程、封锁进程、唤醒进程等。

  * 进程通信：进程间存在进程同步机制（分为同步方式和异步方式），相互合作的进程之间需要交换信息，所以系统需要提供通信机制。

3. **设备管理**
   1. 缓冲区管理：解决CPU和外设不匹配的问题，提高效率
   2. 设备分配：根据用户的I/O请求和相应的分配策略，为该用户分配外设、通道和控制器等。
   3. 设备驱动：实现CPU与通道和外设之间的通信。
   4. 设备无关性（设备独立性）：使用户编写的程序与实际使用的物理设备可无关，由操作系统将用户程序中使用的逻辑设备映射到物理设备。
4. **文件管理**
   1. 文件存储空间的管理：为新文件分配必要的外存，回收释放的文件空间，提高外存利用率
   2. 文件操作的一般管理：文件的创建、打开、关闭等
   3. 目录管理：目录文件的组织、实现用户对文件的“按名存取”，以及目录的快速传和文件共享等。
   4. 文件的读、写管理和存取控制
      * 根据用户请求，从外存中读取数据或将数据写入外存中
      * 为保证文件信息的安全性，防止未授权用户的存取或破坏，对各个文件（包括目录文件）进行存取控制
5. **用户接口服务**

    - 程序接口（系统调用接口）：用户在自己的程序中使用系统调用，从而获取系统提供的众多基层服务

    > 系统调用位于操作系统核心层的最外层，其能把处理机的状态从用户态改为核心态，效率极高

    - 命令行接口：在提示符之后用户从键盘上输入命令，命令解释程序接受并解释这些命令，然后把它们传递给操作系统内部的程序，执行相应的功能。
    - 图形用户接口（GUI，图形用户界面，简称图形界面）：用户利用鼠标、窗口、菜单、图标等图形用户界面工具，直观、方便、有效地使用系统服务和程序。

### 作业

> 我书上勾了下面这些题，但是作业只交了3、19



计算机系统由哪些部分组成？

> 答：硬件和软件。
>
> 硬件：CPU、内存、I/O设备和总线导尿管
>
> 软件：应用软件、支撑软件和系统软件



什么是操作系统，它的主要功能是什么？

> 答：是扩展机器和资源管理器。
>
> 功能：存储管理、作业和进程管理、设备管理、文件管理和用户接口服务



在计算机系统中，操作系统处于什么地位？

> 答：**操作系统是整个计算机系统的控制管理中心，其他所有软件都是建立在操作系统之上。操作系统对他们就有支配权力，又为其运行建造必备环境。**



操作系统的基本特征是什么？

> 答：并发性、共享性、不确定性。



解释一下术语：硬件、软件、多道程序设计、并行、并发、吞吐量、分时、实时、系统调用

> 硬件：软件建立与活动的基础
>
> 软件：对硬件进行管理和功能扩充
>
> 多道程序设计：内存中同时存放多道程序，在管理程序的控制下交替执行
>
> 并行：两个或两个以上事件或活动在同一时刻发生
>
> 并发：两个或两个以上程序在同一事件段内在同一CPU上执行
>
> 吞吐量：单位事件内传输数据的数量
>
> 分时：若干程序对CPU程序的共享
>
> 实时：计算机及时响应请求，在规定时间内处理事件
>
> 系统调用：操作系统内核与用户程序、应用程序之间的接口



12. 什么是处理机的核心态和用户态？为什么要设置这两种不同的状态？

> 核心态（系统态、管理态）：执行操作系统程序，权限较高、能执行所有的指令
>
> 用户态：执行用户用户程序，权限较低、只能执行指令集中的非特权指令
>
> 目的：为了保护操作系统程序(特别是内核部分)，防止收到用户程序的损害

12. 下列哪些指令应该只在核心态下面执行？
    1. 屏蔽所有中断
    2. 读时钟日期
    3. 设置时钟日期
    4. 改变指令地址寄存器的内容
    5. 启动打印机
    6. 清内存

> 只有3是在用户态下执行的，其他的都是核心态。



19. 简述操作系统初启的主要过程。

> 1）硬件检测：BIOS首先执行加电自检程序，完成硬件启动，然后启动系统中配置的硬件（如内存、硬盘）紧2）凑型诊断检测，确定各自在系统中存在，且处于正常状态。
>
> 3）加载引导程序：
>
> ​	a. CPU的初始化，如页式映射的建立
>
> ​	b. 系统中一些基础设施的初始化，如内存管理和进程管理的初始化
>
> ​	c. 对上层部分初始化，如根设备的安装和外部设备的初始化
>
> 4）用户登录：init程序在每个tty端口上创建进程，用以支持用户登录



## 第二章	进程和线程

### 2.1 进程概念

* 顺序程序活动的特点：顺序性、封闭性、可再现性

- 多道程序设计（并发执行程序）

  - 优点：**提高系统资源利用率和增加作业吞吐量**
  - 缺点：**并发和共享增加系统复杂性，且调度程序增加损耗**
  - 特征：

    - 失去封闭性：程序的执行时断时续，并不完全封闭
    - 程序与计算不一一对应：一个程序对应多个进程，进行不同计算
    - 并发程序在执行期间相互制约：逻辑上彼此独立的程序由于共用独占资源形成制约关系，如打印机的使用，a程序使用时，b程序必须等待

- 进程概念 

  - 引入：用程序无法表示多个程序并发执行过程，因此引入进程的概念来描述程序动态执行过程的性质
  - 定义：一个具有独立功能的程序关于某个数据集合的一次运行活动，简单说——程序在并发环境中的执行过程
  - 性质：

    - 动态性：动态产生、消亡
    - 并发性
    - 非对应性：程序和进程没有对应关系，一个程序可被多个进程共用，一个进程可顺序执行多个程序
    - 异步性：各个进程在并发执行时相互制约，前进速度不可预测

- ### 2.2 进程的状态和组成

- 基本状态

  - 运行状态：当前进程已分配到CPU，其程序正在处理器上执行

  - 就绪状态：进程已具备运行条件，由于其他进程正在占用CPU，使其处于等待分配CPU的状态

  - 阻塞状态（等待状态）：进程正在等待某事件完成，如等待输入等，其尚不具备运行条件

  > 某些系统还加了两个状态：
  >
  > 新建状态：进程刚被创建，尚未进入就绪队列，该进程并不完全。
  >
  > 终止状态：进程完成任务而正常终止，或其运行期间出现错误而被迫终止（非正常终止）时所处状态。处于该状态的进程即将被系统撤销。

  ![img](https://raw.githubusercontent.com/deepbluefantasy/markdown-image/master/操作系统/进程基本状态.jpg)


- 进程映像(image)=PCB+程序+数据
  - 程序和数据是组成进程的实体

  - PCB（进程控制块/进程描述块）：描述进程当前状态、本身特性、资源占用和调度信息等的数据结构。

      - 组成

        - 进程名：唯一的标志对应进程的一个标志符或数字
        - 特征信息：该进程为系统进程？用户进程？是否常驻内存？
        - 进程状态信息：运行状态？就绪状态？阻塞状态？
        - 调度优先权
        - 通信信息：反映该进程与其他进程之间的通信关系
        - 现场保护区：进程由运行态转阻塞态时，用以保存现场信息
        - 资源需求、分配和控制信息
        - 进程实体信息：该进程的程序和数据的存储情况？在内存或外存的地址、大小
        - 族系关系：反映父子进程的隶属关系
        - 其他信息

      - 作用

        - **每个进程有唯一的PCB**
        - 操作系统根据PCB对进程实施控制和管理
        - 进程的动态、并发等特征是利用PCB表现出来的
        - **PCB是进程存在的唯一标志**

- 进程队列

 > 操作系统以队列方式管理进程

  - 线性方式（早期unix系统，**简单**但缺点很大）
  - 链接方式（现代 unix系统）
  - 索引方式：建立索引表

### 2.3 进程管理

- 进程图：描述进程族系关系的有向树

  - 族系关系：除0号进程外，所有进程都由父进程创建

    > 0号进程：系统生成的第一个进程

- 进程创建：父进程动态创建子进程

  - 创建新进程的时机

    - 调度新作业：把进程
    - 用户登录
    - 操作系统提供特定服务
    - 派生新进程：老进程显示创建新进程

  - 操作步骤

    - 申请一个空闲的PCB
    - 为新进程分配资源：分配内存……
    - 将新进程的PCB初始化：初始化进程名、父进程标识符……
    - 将新进程加到就绪队列中

- 进程终止

    - 正常终止：进程完成任务后，使用exit系统调用，请求操作系统删除自己
    - 异常终止
      - 运行超时：进程运行时间超过指定的时间限制
      - 内存不足：进程请求的进程超过系统可提供的量
      - 越界错误：进程试图存取不准许其存取的内存单元
      - ……
    - 外部干扰	
      - 操作员或操作系统的干预
      - 父进程终止：父进程终止时，操作系统自动终止其所有子进程
      - 父进程请求：父进程有权终止其任何子孙进程
    - 进程终止的操作
      - 从系统PCB表中找到指定进程的PCB，若其处于运行状态，终止该进程
      - 回收进程所占的所有资源
      - 终止其子孙进程，并回收资源
      - 将该进程的PCB从原来队列中摘走，以后由父进程获取数据，并释放它

- 进程阻塞

    1. 立即停止当前进程的执行
    2. 将现场进程的CPU进程送到该进程的PCB现场保护区中保存，以便重新运行时恢复此时的现场
    3. 把该进程PCB中的现行状态由“运行”改为“阻塞“，把该进程插到具有相同事件的阻塞队列中
    4. 转到进程调度程序，从就绪队列挑选合适进程投入运行

- 进程唤醒

    1. 把阻塞进程从相应的阻塞队列摘下
    2. 将现行状态改为就绪状态，然后把该进程插入就绪队列
    3. 如果被唤醒的进程比当前运行进程的优先级更高，则重新设置调度标志

### 2.4 线程

- 产生原因：进程的开销过大，系统中进程的数目和并发程度受限
- 定义：进程中实施调度和分派的基本单位

### 2.5 进程的同步和互斥

* 同步：进程间进行通信，协作完成任务

  > 定义：逻辑上相关的两个或多个进程为完成一项任务，通过协调活动来使用同一资源，而产生的执行时序的约束关系

* 互斥：进程间抢夺资源

  > 定义：逻辑上相互无关的两个或多个进程由于争用同一资源而发生的相互制约关系

* 竞争条件：两个或多个进程同时访问和操作相同的数据时，最后的执行结果取决于进程运行的精确时序的情况

* 临界资源：一次仅允许一个进程使用的共享资源（如打印机、读卡器……）

* 临界区：每个进程中访问临界资源的程序

``注意：从这个地方开始，笔记就不怎么全了。后面断断续续地写了些日记，仅对重要内容进行整理``

* 原语：又称原子操作，是机器指令的延伸，在执行时不可分割、不可中断、不可并发。

* 信号量

  * 整型信号量：S代表当前资源的数目
    * P（S）：当S > 0时，S--，向下执行；否则，循环测试。
    * V（S）：S++

  > 缺点：试图进入临界区的进程会在入口处循环测试，浪费CPU

  * 结构性信号量（计数信号量）

    * S.value > 0, 表示资源数目

    * S.value < 0, 表示排队进程数目

    * P（S）原语
```伪代码
void P(semaphore S){
	S.value--;
	if(S.value < 0){
	把这个进程加入S.list队列；
	block();
	}
}
```

    * V（S）原语

```
void V(semaphore S){
	S.value++;
	if(S.value <= 0){
	从S.list队列中移走进程Q；
	wakeup(Q);
	}
}
```

### 2.6 经典进程同步问题

#### 生产者-消费者问题

- 生产者：产生并释放资源的进程
- 消费者：单纯使用资源的进程
  - 注意：一个进程在不同的关系中，既可能是生产者，也可能是消费者
- 代码：

```
Producer:
while(1){
    P(empty);
    P(mutex);
    产品送往buffer(in);
    in = (in + 1) mod N; //有N个单元
    V(mutex);
    V(full);
}

Consumer:
while(1){
    P(full);
    P(mutex);
    从buffer(out)中取出产品;
    out = (out + 1) mod N; //有N个单元
    V(mutex);
    V(empty);
}
```

#### 读者-写者问题

- 问题描述：一个数据库，允许以下情况
  - 多个进程可同时进行读操作，但任意写者进程不可进行写操作
  - 一个写者进程进行写操作，但任意其他进程不可操作（读或写）
- 方法一--------资源申请（读者优先）：
  - 读者
    - 第一个读者需无人使用数据区
    - 其他读者需要已有读者进程使用数据区
  - 写者
    - 无人使用数据区
  - 弊端：读者进程可插队，导致写者进程总是在等待，有失公允
- 方法二--------资源申请（写者优先）
  - 在方法一的基础上，增加以下规则：
    - 当有写者进程开始排队时，其他读者进程不可插队使用数据区

#### 哲学家进餐问题

- 问题描述：5个哲学家一起进餐，5个筷子，哲学家进餐需2个筷子，可能导致死锁。
- 解决办法
  - 只允许最多只允许4个哲学家同时拿筷子
  - 仅当哲学家能得到2个筷子时允许进餐（程序中占用资源较多）
  - 奇数号哲学家先拿左边筷子，偶数号哲学家先拿右边筷子（效率低）

#### 打瞌睡的理发师问题

> 讲这个问题的时候我可能在打瞌睡，没做笔记

### 作业

3. 进程的基本状态有哪几种？试描绘进程状态转换图。

答：运行状态；阻塞状态；就绪状态。

![img](https://raw.githubusercontent.com/deepbluefantasy/markdown-image/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/a28904034d6064f947f8d47f22e313d2.jpg)

9. 简述计数信号量的定义和作用。P、V操作的原语是如何定义的？

定义：略。

作用：实现进程互斥和简单同步。

* P（S）原语
```伪代码
void P(semaphore S){
	S.value--;
	if(S.value < 0){
	把这个进程加入S.list队列；
	block();
	}
}
```

* V（S）原语

```
void V(semaphore S){
	S.value++;
	if(S.value <= 0){
	从S.list队列中移走进程Q；
	wakeup(Q);
	}
}
```

11. 题太长，略。见p67。

15. 题太长，略。见p67。

## 第三章	死锁

### 3.1 资源

* 资源种类
    * 硬件资源
    * 软件资源
* 资源按分配性质可分为：
    * 独占资源：只允许一个进程使用，直至使用完成
    * 共享资源：允许多个进程并发使用
* 资源按照占用方式可分为：
    * 可抢占资源：进程可去已拥有进程处抢夺，且不会产生问题（如内存）
    * 不可抢占资源：进程不可去已拥有进程处抢夺，否则会出现问题（如刻光盘时的刻录机，一旦被抢夺，光盘就会作废）

### 3.2 死锁概念
* **类比**：A、B两车开上了同一个窄桥，导致两辆车都无法通过桥
    * 解决办法1：一车后退让路（释放资源）
    * 解决办法2：一车进入后，封锁另一端的路口（独占配套资源）
    * 解决办法3：一车确认桥上无车后，再上桥（确保资源足够）
* **定义**：一个进程集合中，每个进程都在等待仅由该集合中的另一个进程才能引发的事件，而无限期僵持的局面
    * 该事件多为：释放其占用的资源（即每个进程都期待获得另一个进程占用的资源）
* **根本原因**：资源有限且操作不当
    * 即竞争资源；进程推进顺序不合适（如下图）。

![imag](https://raw.githubusercontent.com/deepbluefantasy/markdown-image/master/操作系统/进程推进对死锁的影响.jpg)

* **死锁发生的必要条件**
    * 互斥条件：所需资源是独占资源
    * 占有且等待条件：进程至少已经占有一个资源，而又在等待另一个资源
    * 不可抢占条件：所需资源是不可抢占资源
    * 循环等待条件：资源分配图存在环
        * 资源分配图见P74，画图理解
* **处理死锁的办法**
    * 预防、避免死锁
    * 找到死锁并解除（难）
    * 忽略死锁（许多操作系统都这么做，如unix）

### 3.3 死锁的预防
* 破坏互斥条件→不现实，有些资源就是独占的

* 破坏占有且等待条件

    * 预分配策略：进程在开始执行之前就申请并得到所有所需资源（**静态分配**）

    * >  不现实，天知道你要哪些资源

    * “空手”申请资源策略：每个进程仅在其不占有资源时可申请资源

        > 可能出现饥饿情况，如某个进程需大量资源，则很容易一直空手

    * 缺点：资源利用率低、进程并发性降低

* 破坏非抢占条件

    * 一般用于资源易于保留和恢复的环境中，如内存空间，不能用于打印机等资源

* 破坏循环等待条件

    * 资源有序分配：所有进程对资源的申请严格按照序号递增的次序进行
    * 缺点：限制了进程对资源的请求，编号也会增加系统开销

### 3.4 死锁的避免
> 上一节讲到的死锁预防是排除死锁的**静态策略**，但副作用是降低资源利用率和减少系统吞吐量。本节介绍的是排除死锁的**动态策略**，其对进程发出的申请资源命令加以检查，若可能发生死锁，则不分配资源。

#### 安全状态算法
* **安全序列**：针对当前分配状态，系统至少能够按照某种次序为每个进程分配资源，并使其一次成功地运行完毕，这种进程序列则为安全序列

* **安全状态**：至少存在一个安全序列

    * 系统处于不安全状态是死锁发生的必要条件，即**死锁是不安全状态中的特例**

    > 在不安全状态下，如果有资源补充，就不会死锁

* **避免系统进入死锁的算法**：当一个进程申请一个可用资源时，系统必须决定：是否立即交出资源，仅当系统处于安全状态时交出资源
> 这个应该就是银行家算法

* 总而言之
    * 死锁状态是不安全状态
    * 系统处于不安全状态表示存在导致死锁的危机（如果条件不变，则必然导致死锁）
    * 若某进程申请的资源当前可用，为避免死锁，该进程也可能必须等待，此时资源利用率会下降
#### 资源分配图算法

> 画图好麻烦，见书P79
>
> 总之，存在环路说明系统处于不安全状态。

#### 银行家算法（p79）
* **设计思想**：当用户申请一组资源时，系统进行判断：若资源分配出去后，系统仍处于安全状态，则分配；否则，不分配。
> 这个算法很重要，看书吧~

### 3.5 死锁的检测与恢复

检测：

* 对单体资源类的检测：画等待图（去掉资源类节点的资源费配图），当且仅当图中有环路，存在死锁。
* 对多体资源类的检测：用银行家算法的表，找存不存在安全序列。

恢复：

* 通过抢占资源实现恢复
* 通过回退执行实现恢复
* 通过杀掉进程实现恢复

饥饿（饿死）：

* 定义：在一定时间内，某个进程由于调度策略永远也无法从就绪状态转入运行状态。
* 例子：最短作业优先策略中的某一个大作业，如果一直有稳定的小进程流加入队列，那么他就会一直被插队

活锁：

* 定义：某进程轮询地等待某个不可能为真的条件为真，导致重复尝试、失败、尝试……

* 例子：某进程被调度运行，由于算法故障或数据问题，运行一会又退到就绪队列；过一会又被调度运行……

  > 见书p85，我写不清楚。

 

### 3.6 处理死锁的综合方式

![img](https://raw.githubusercontent.com/deepbluefantasy/markdown-image/master/操作系统/处理死锁的方法.jpg)

#### 作业

2. 计算机系统中出现死锁的根本原因是什么？

答：资源有限且操作不当。

4. 解决死锁的办法有哪三种？

答：预防、避免死锁；发现死锁并处理；忽略死锁。

16. 题太长，略。见p89。

## 第四章	调度

> 几乎所有计算机资源在被使用之前都要经过调度，其中CPU是计算机最主要的资源

#### 4.1 调度类型
* **高级调度**：即作业调度，又称长期调度
    * 在作业后备队列中选择一个作业，为其申请必要的资源，**创建进程**，并将进程挂入进程就绪队列
    * 一般在批处理操作系统中存在作业调度
    * 目标：平均周转时间短
* **中级调度**：即进程挂起与对换，又称中期调度
    * 内存有限，无法在内存中放入所有进程，因此可以*调度某些进程的部分或全部代目放到外存*
    * 在虚拟存储技术中使用
    * 目标：使内存的命中率高
* **低级调度**：即进程调度，又称短期调度
    * 在进程就绪队列中选择一个进程分配cpu
    * 该算法使用频繁，要求高效，有的机器直接写到了硬件上
    * 由一个进程调度程序实现，运行频率极高（几十毫秒一次）
    * 目标：平均周转时间短，CPU利用率高
> 也可按操作系统的类型分类：批处理调度、交互式系统调度、实时调度、多处理机调度

#### 4.2 作业调度
1. 作业状态
    1. 提交状态：作业在提交当中
    2. 后备状态：作业已经进入输入井
    3. 执行状态：调入内存，变成进程
    4. 完成状态：作业完成，准备退出系统
2. 作业类型
    1. **CPU繁忙型**：需要的计算多，利用CPU空闲时调度

    > 因为很少使用IO

    1. **IO繁忙型**：优先调度
    2. **内存繁忙型**：根据内存使用情况调度
3. 常用作业调度算法
    1. 先来先服务法（公平，效率低）
    2. 短作业优先法（不公平，效率高）->非抢占方式
    3. 最短剩余时间优先法->抢占方式

#### 4.3 进程调度
1. **进程调度的功能**
    1. 保存现场
    2. 挑选进程
    3. 恢复现场
2. **进程调度的时机**：运行进程和就绪进程队列发生变化
    1. 创建新进程
    2. 进程终止
    3. 等待事件发生 
    4. 中断发生：即新就绪进程抢占当前进程CPU
    5. 运行时间片到时
3. **进程调度的基本方式**
    1. 非抢占方式：正在运行的进程自主放弃CPU
    2. 抢占方式：高优先级就绪进程可以抢占CPU
4. **两级调度模型**
    * 作业调度是宏观调度，只是把选择的作业创建进程（**不是必要的**）
    * 进程调度是微观调度，把处理机实际地分配给进程（**必要**）

#### 4.4 调度准则

需要考虑的因素：（我觉得是）公平、效率和复杂度。

> 书上写了一大堆，不好记。

评价准则：

1. CPU利用率
2. 吞吐量：单位时间内CPU完成作业的数量
3. 周转时间：从作业提交到作业完成的时间间隔（详见p97）
    1. **平均周转时间**：衡量不同算法对相同作业流的调度性能
    2. **平均带权周转时间**：衡量某调度算法对不同作业流的调度性能
4. 就绪等待时间：进程在就绪队列当中的排队时间
5. 响应时间：提交第一个作业，到产生第一个响应用到的时间（比周转时间短一些）

#### 4.5 调度算法
1. 先来先服务法（FCFS算法）
    * 有利于长作业进程
    * 有利于CPU繁忙型
    * 周转时间和带权周转时间较大
    * 算法容易，效率较低
2. 短作业优先
    * 实现有困难
    * 对长作业不利
3. 最短剩余时间优先法：短作业优先思想的极致版，短作业可以抢占CPU
4. 优先级法
    * 优先数越小，优先级越高，0的优先级最高（UNIX系统）
    * 分抢占式和非抢占式
5. 轮转法：先来先服务法的改良版，按照时间片进行轮转
6. 高响应比优先法……

//2019.1.7 22:21 肝不动了，退学吧。

## 第五章	存储管理

## 第六章	文件系统

## 第七章	I/O管理